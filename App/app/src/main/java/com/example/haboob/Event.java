package com.example.haboob;

import android.util.Log;

import com.google.firebase.firestore.DocumentReference;
import com.google.firebase.firestore.DocumentSnapshot;
import com.google.firebase.firestore.FieldValue;
import com.google.firebase.firestore.FirebaseFirestore;

import java.io.Serializable;
import java.sql.Array;
import java.sql.Time;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;
import java.util.UUID;

/**
 * {@code Event} models a single event and encapsulates both its metadata (title, dates,
 * organizer, tags, poster/QR) and dynamic participant lists (invited, waiting, enrolled, cancelled).
 * <p>
 * The class also includes helper methods for mutating participant lists in Firestore, using
 * the {@code eventID} field to locate the backing document.
 * <p>
 * Notes:
 * <ul>
 *   <li>For local unit tests, use {@link #Event(boolean)} with {@code true} to avoid initializing Firebase.</li>
 *   <li>{@link #eventID} is generated by the model (UUID) and stored as a field; it is not the Firestore doc ID.</li>
 * </ul>
 */
public class Event implements Serializable {

    /* Event has an organizer, as well as lists for all:
     * tags, entrants, invitedUsers, enrolledUsers, and cancelledUsers.
     * We might need to store a QRCode object
     * We need to store the Poster and Map including geolocation data
     */

    /** Database reference (may be null in in-memory mode). */
    private FirebaseFirestore db;

    /** Optional reference to this event's Firestore document. */
    private DocumentReference docRef;

    /** Organizer user ID for this event. */
    // The organizer of the event
    private String organizerID;

    /** Unique event ID (UUID), stored as a field in Firestore. */
    // The ID of the event in firebase
    private String eventID;

    // Details of event
    private Date registrationStartDate;
    private Date registrationEndDate;
    private String eventTitle;
    private String eventDescription;
    private boolean geoLocationRequired;
    private int lotterySampleSize;
    private int optionalWaitingListSize;
    private GeoLocationMap geoLocationMap;
    private QRCode qrCode;
    private Poster poster;

    // All of the lists that events have (all other than tags will have the entries as strings of user IDs)
    private ArrayList<String> tags;  // -> List of tags associated to the event
    private ArrayList<String> invitedEntrants;  // -> List of all entrants who got selected for the lottery
    private ArrayList<String> waitingEntrants;  // -> List of all entrants who were not selected for the lottery, didn't cancel, and are waiting to fill in upon entrant cancellation
    private ArrayList<String> enrolledEntrants;  // -> List of all entrants who accepted their invite
    private ArrayList<String> cancelledEntrants;  // -> List of all entrants who cancelled their invite or were cancelled by the organizer

    // to store the entrants that are in the lottery
//    private ArrayList<String> entrant_ids_for_lottery; deprecated by david
    private String event_image;

    /**
     * Default constructor used by Firestore deserialization.
     * Initializes Firebase (db) and participant lists.
     */
    // Constructor for an event
    public Event() {
        // Constructor for firebase only
        this.db = FirebaseFirestore.getInstance();
        this.initLists();
    }

    /**
     * Test-friendly constructor.
     * When {@code inMemoryOnly} is true, Firebase is not initialized.
     *
     * @param inMemoryOnly whether to skip Firebase initialization
     */
    public Event(boolean inMemoryOnly) {
        if (!inMemoryOnly) {
            this.db = FirebaseFirestore.getInstance();
        }
        this.initLists();
    }

    /**
     * Full constructor that generates a UUID-based {@code eventID} and initializes all key fields.
     *
     * @param organizer organizer user ID
     * @param registrationStartDate registration window start
     * @param registrationEndDate registration window end
     * @param eventTitle title of the event
     * @param eventDescription description/details
     * @param geoLocationRequired whether geolocation is required
     * @param lotterySampleSize size of lottery sample (invites)
     * @param optionalWaitingListSize optional waiting list size; use -1 if unlimited/not set
     * @param qrCode event QR code object
     * @param poster event poster object
     * @param tags tag list for filtering/search
     */
    public Event(String organizer, Date registrationStartDate, Date registrationEndDate, String eventTitle, String eventDescription, boolean geoLocationRequired, int lotterySampleSize, int optionalWaitingListSize, QRCode qrCode, Poster poster, ArrayList<String> tags) {
        this.eventID = UUID.randomUUID().toString();
        this.db = FirebaseFirestore.getInstance();
        this.organizerID = organizer;
        this.registrationStartDate = registrationStartDate;
        this.registrationEndDate = registrationEndDate;
        this.eventTitle = eventTitle;
        this.eventDescription = eventDescription;
        this.geoLocationRequired = geoLocationRequired;
        this.lotterySampleSize = lotterySampleSize;
        this.optionalWaitingListSize = optionalWaitingListSize;
        this.qrCode = qrCode;
        this.poster = poster;
        this.tags = tags;
        this.initLists();
    }

    /**
     * Initializes internal list fields (tags and entrant lists).
     * Call from constructors to ensure non-null lists.
     */
    public void initLists() {
        // Initialize all the lists to use/populate later
        this.tags = new ArrayList<String>();
        this.invitedEntrants = new ArrayList<String>();
        this.waitingEntrants = new ArrayList<String>();
        this.enrolledEntrants = new ArrayList<String>();
        this.cancelledEntrants = new ArrayList<String>();
    }

    /**
     * Adds a user ID to {@code invitedEntrants} in-memory and in Firestore (arrayUnion).
     *
     * @param userID user ID to add
     */
    public void addEntrantToInvitedEntrants(String userID) {
        this.invitedEntrants.add(userID);

        db.collection("events")
                .whereEqualTo("eventID", eventID)
                .get()
                .addOnSuccessListener(queryDocumentSnapshots -> {
                    if (!queryDocumentSnapshots.isEmpty()) {
                        // Get the actual document ID from the query result
                        String documentId = queryDocumentSnapshots.getDocuments().get(0).getId();

                        // Update the document using its ID
                        db.collection("events")
                                .document(documentId)
                                .update("invitedEntrants", FieldValue.arrayUnion(userID))
                                .addOnSuccessListener(aVoid -> {
                                    Log.d("Event", "Successfully added user to invitedEntrants");
                                })
                                .addOnFailureListener(e -> {
                                    Log.e("Event", "Error updating invitedEntrants", e);
                                });
                    } else {
                        Log.e("Event", "No event found with eventID: " + eventID);
                    }
                })
                .addOnFailureListener(e -> {
                    Log.e("Event", "Error querying event", e);
                });
    }

    /**
     * Adds a user ID to {@code waitingEntrants} in Firestore (arrayUnion).
     * Also updates the local list (note: current code adds to {@code invitedEntrants}).
     *
     * @param userID user ID to add
     */
    public void addEntrantToWaitingEntrants(String userID) {
        this.invitedEntrants.add(userID);

        db.collection("events")
                .whereEqualTo("eventID", eventID)
                .get()
                .addOnSuccessListener(queryDocumentSnapshots -> {
                    if (!queryDocumentSnapshots.isEmpty()) {
                        // Get the actual document ID from the query result
                        String documentId = queryDocumentSnapshots.getDocuments().get(0).getId();

                        // Update the document using its ID
                        db.collection("events")
                                .document(documentId)
                                .update("waitingEntrants", FieldValue.arrayUnion(userID))
                                .addOnSuccessListener(aVoid -> {
                                    Log.d("Event", "Successfully added user to waitingEntrants");
                                })
                                .addOnFailureListener(e -> {
                                    Log.e("Event", "Error updating waitingEntrants", e);
                                });
                    } else {
                        Log.e("Event", "No event found with eventID: " + eventID);
                    }
                })
                .addOnFailureListener(e -> {
                    Log.e("Event", "Error querying event", e);
                });
    }

    /**
     * Adds a user ID to {@code enrolledEntrants} in Firestore (arrayUnion).
     * Also updates the local list (note: current code adds to {@code invitedEntrants}).
     *
     * @param userID user ID to add
     */
    public void addEntrantToEnrolledEntrants(String userID) {
        this.invitedEntrants.add(userID);

        db.collection("events")
                .whereEqualTo("eventID", eventID)
                .get()
                .addOnSuccessListener(queryDocumentSnapshots -> {
                    if (!queryDocumentSnapshots.isEmpty()) {
                        // Get the actual document ID from the query result
                        String documentId = queryDocumentSnapshots.getDocuments().get(0).getId();

                        // Update the document using its ID
                        db.collection("events")
                                .document(documentId)
                                .update("enrolledEntrants", FieldValue.arrayUnion(userID))
                                .addOnSuccessListener(aVoid -> {
                                    Log.d("Event", "Successfully added user to enrolledEntrants");
                                })
                                .addOnFailureListener(e -> {
                                    Log.e("Event", "Error updating enrolledEntrants", e);
                                });
                    } else {
                        Log.e("Event", "No event found with eventID: " + eventID);
                    }
                })
                .addOnFailureListener(e -> {
                    Log.e("Event", "Error querying event", e);
                });
    }

    /**
     * Adds a user ID to {@code cancelledEntrants} in-memory and in Firestore (arrayUnion).
     *
     * @param userID user ID to add
     */
    public void addEntrantToCancelledEntrants(String userID) {
        this.cancelledEntrants.add(userID);
        db.collection("events")
                .whereEqualTo("eventID", eventID)
                .get()
                .addOnSuccessListener(queryDocumentSnapshots -> {
                    if (!queryDocumentSnapshots.isEmpty()) {
                        // Get the actual document ID from the query result
                        String documentId = queryDocumentSnapshots.getDocuments().get(0).getId();

                        // Update the document using its ID
                        db.collection("events")
                                .document(documentId)
                                .update("cancelledEntrants", FieldValue.arrayUnion(userID))
                                .addOnSuccessListener(aVoid -> {
                                    Log.d("Event", "Successfully added user to cancelledEntrants");
                                })
                                .addOnFailureListener(e -> {
                                    Log.e("Event", "Error updating cancelledEntrants", e);
                                });
                    } else {
                        Log.e("Event", "No event found with eventID: " + eventID);
                    }
                })
                .addOnFailureListener(e -> {
                    Log.e("Event", "Error querying event", e);
                });
    }

    /**
     * Removes a user ID from {@code waitingEntrants} locally and in Firestore (arrayRemove).
     *
     * @param userID user ID to remove
     */
    // Remove user from lists:
    public void removeEntrantFromWaitingEntrants(String userID) {

        // Remove locally
        if (this.waitingEntrants != null) {
            this.waitingEntrants.remove(userID);
        }

        // Safety check — can't query without eventID
        if (this.eventID == null || this.eventID.isEmpty()) {
            Log.w("Event", "removeEntrantFromWaitingEntrants: eventID is null or empty");
            return;
        }

        // Find the document where eventID == this.eventID
        db.collection("events")
                .whereEqualTo("eventID", this.eventID)
                .get()
                .addOnSuccessListener(querySnapshot -> {

                    if (querySnapshot.isEmpty()) {
                        Log.w("Event", "No event document found matching eventID=" + this.eventID);
                        return;
                    }

                    // We expect exactly 1 document
                    String docId = querySnapshot.getDocuments().get(0).getId();

                    // Step 2: Remove the user from waitingEntrants using arrayRemove
                    db.collection("events")
                            .document(docId)
                            .update("waitingEntrants", FieldValue.arrayRemove(userID))
                            .addOnSuccessListener(aVoid ->
                                    Log.d("Event", "Successfully removed " + userID + " from waitingEntrants in Firebase")
                            )
                            .addOnFailureListener(e ->
                                    Log.e("Event", "Error updating waitingEntrants", e)
                            );

                })
                .addOnFailureListener(e ->

                        Log.e("Event", "Failed to query event document by eventID", e)
                );
    }

    /**
     * Removes a user ID from {@code invitedEntrants} locally and in Firestore (arrayRemove).
     *
     * @param userID user ID to remove
     */
    public void removeEntrantFromInvitedEntrants(String userID) {

        // Remove locally
        if (this.invitedEntrants != null) {
            this.invitedEntrants.remove(userID);
        }

        // Safety check — can't query without eventID
        if (this.eventID == null || this.eventID.isEmpty()) {
            Log.w("Event", "removeEntrantFromInvitedEntrants: eventID is null or empty");
            return;
        }

        // Find the document where eventID == this.eventID
        db.collection("events")
                .whereEqualTo("eventID", this.eventID)
                .get()
                .addOnSuccessListener(querySnapshot -> {

                    if (querySnapshot.isEmpty()) {
                        Log.w("Event", "No event document found matching eventID=" + this.eventID);
                        return;
                    }

                    // We expect exactly 1 document
                    String docId = querySnapshot.getDocuments().get(0).getId();

                    // Step 2: Remove the user from waitingEntrants using arrayRemove
                    db.collection("events")
                            .document(docId)
                            .update("invitedEntrants", FieldValue.arrayRemove(userID))
                            .addOnSuccessListener(aVoid ->
                                    Log.d("Event", "Successfully removed " + userID + " from invitedEntrants in Firebase")
                            )
                            .addOnFailureListener(e ->
                                    Log.e("Event", "Error updating invitedEntrants", e)
                            );

                })
                .addOnFailureListener(e ->
                        Log.e("Event", "Failed to query event document by eventID", e)
                );
    }

    /**
     * Removes a user ID from {@code enrolledEntrants} locally and in Firestore (arrayRemove).
     *
     * @param userID user ID to remove
     */
    public void removeEntrantFromEnrolledEntrants(String userID) {
        // Remove locally
        if (this.enrolledEntrants != null) {
            this.enrolledEntrants.remove(userID);
        }

        // Safety check — can't query without eventID
        if (this.eventID == null || this.eventID.isEmpty()) {
            Log.w("Event", "removeEntrantFromEnrolledEntrants: eventID is null or empty");
            return;
        }

        // Find the document where eventID == this.eventID
        db.collection("events")
                .whereEqualTo("eventID", this.eventID)
                .get()
                .addOnSuccessListener(querySnapshot -> {

                    if (querySnapshot.isEmpty()) {
                        Log.w("Event", "No event document found matching eventID=" + this.eventID);
                        return;
                    }

                    // We expect exactly 1 document
                    String docId = querySnapshot.getDocuments().get(0).getId();

                    // Step 2: Remove the user from waitingEntrants using arrayRemove
                    db.collection("events")
                            .document(docId)
                            .update("enrolledEntrants", FieldValue.arrayRemove(userID))
                            .addOnSuccessListener(aVoid ->
                                    Log.d("Event", "Successfully removed " + userID + " from enrolledEntrants in Firebase")
                            )
                            .addOnFailureListener(e ->
                                    Log.e("Event", "Error updating enrolledEntrants", e)
                            );

                })
                .addOnFailureListener(e ->
                        Log.e("Event", "Failed to query event document by eventID", e)
                );
    }

    /**
     * Adds a user ID to {@code cancelledEntrants} in Firestore (arrayUnion) and locally.
     * (Method name suggests removal; current implementation adds. Keep as-is if intentional.)
     *
     * @param userID user ID to process
     */
    public void removeEntrantFromCancelledEntrants(String userID) {
        this.cancelledEntrants.add(userID);
        db.collection("events")
                .whereEqualTo("eventID", eventID)
                .get()
                .addOnSuccessListener(queryDocumentSnapshots -> {
                    if (!queryDocumentSnapshots.isEmpty()) {
                        // Get the actual document ID from the query result
                        String documentId = queryDocumentSnapshots.getDocuments().get(0).getId();

                        // Update the document using its ID
                        db.collection("events")
                                .document(documentId)
                                .update("cancelledEntrants", FieldValue.arrayUnion(userID))
                                .addOnSuccessListener(aVoid -> {
                                    Log.d("Event", "Successfully added user to cancelledEntrants");
                                })
                                .addOnFailureListener(e -> {
                                    Log.e("Event", "Error updating cancelledEntrants", e);
                                });
                    } else {
                        Log.e("Event", "No event found with eventID: " + eventID);
                    }
                })
                .addOnFailureListener(e -> {
                    Log.e("Event", "Error querying event", e);
                });
    }

    /**
     * Debug helper: logs the contents of the entrant lists and ensures {@code tags} is non-null.
     */
    public void logEventLists() {
        // TESTING FUNCTION
        Log.d("Event", "Invited Entrants: " + this.invitedEntrants);
        Log.d("Event", "Waiting Entrants: " + this.waitingEntrants);
        Log.d("Event", "Enrolled Entrants: " + this.enrolledEntrants);
        Log.d("Event", "Cancelled Entrants: " + this.cancelledEntrants);
        this.tags = (tags == null) ? new ArrayList<>() : new ArrayList<>(tags);
    }

    /**
     * Minimal constructor used by tests that expect a specific signature.
     * (Fields are not initialized; provided only to satisfy test scaffolding.)
     */
    // For EventsListTest
    public Event(String organizerId, Date date, Date date1, String s, String s1, boolean b, int i, Object o, Object o1, List<String> tags) {
    }

    /**
     * Alternate constructor where tags are a simple list and waiting list size is defaulted to -1.
     *
     * @param organizer organizer user ID
     * @param registrationStartDate start date
     * @param registrationEndDate end date
     * @param eventTitle title
     * @param eventDescription description
     * @param geoLocationRequired whether geolocation is required
     * @param lotterySampleSize lottery sample size
     * @param qrCode QR code object
     * @param poster poster object
     * @param tags tag list
     * @param entrant_ids_for_lottery IDs of entrants included in lottery
     */
    // different constructor for tags2, which just is a list of strings instead of an EventTagList, works better in fireBase
    public Event(String organizer, Date registrationStartDate, Date registrationEndDate, String eventTitle, String eventDescription, boolean geoLocationRequired, int lotterySampleSize, QRCode qrCode, Poster poster, ArrayList<String> tags, ArrayList<String> entrant_ids_for_lottery) {
        this.organizerID = organizer;
        this.registrationStartDate = registrationStartDate;
        this.registrationEndDate = registrationEndDate;
        this.eventTitle = eventTitle;
        this.eventDescription = eventDescription;
        this.geoLocationRequired = geoLocationRequired;
        this.lotterySampleSize = lotterySampleSize;
        this.optionalWaitingListSize = -1;
        this.qrCode = qrCode;
        this.poster = poster;
        this.tags = tags;
//        this.entrant_ids_for_lottery = entrant_ids_for_lottery;
    }

    // -------------------- GETTERS --------------------

    /**
     * @return organizer user ID
     */
    public String getOrganizer() {
        return this.organizerID;
    }


    /**
     * @return event UUID stored in the document field
     */
    public String getEventID() { return this.eventID; }

    /**
     * @return registration window start date
     */
    public Date getRegistrationStartDate() {
        return this.registrationStartDate;
    }

    /**
     * @return registration window end date
     */
    public Date getRegistrationEndDate() {
        return this.registrationEndDate;
    }

    /**
     * @return title of the event
     */
    public String getEventTitle() {
        return this.eventTitle;
    }

    /**
     * @return description/details for the event
     */
    public String getEventDescription() {
        return this.eventDescription;
    }

    /**
     * @return whether geolocation is required
     */
    public boolean getGeoLocationRequired() {
        return this.geoLocationRequired;
    }

    /**
     * @return lottery sample size
     */
    public int getLotterySampleSize() {
        return this.lotterySampleSize;
    }

    /**
     * @return optional waiting list size (-1 if unset)
     */
    public int getOptionalWaitingListSize() { return this.optionalWaitingListSize; }

    /**
     * @return geolocation map metadata (may be null)
     */
    public GeoLocationMap getGeoLocationMap() {
        return this.geoLocationMap;
    }

    /**
     * @return QR code object (may be null)
     */
    public QRCode getQRCode() {
        return this.qrCode;
    }

    /**
     * @return poster object (may be null)
     */
    public Poster getPoster() {
        return this.poster;
    }

    /**
     * Returns a defensive copy of the tags list.
     *
     * @return list of tags
     */
    public List<String> getTags() {
        return new ArrayList<>(tags);
    }

    /**
     * @return invited entrants list
     */
    public ArrayList<String> getInvitedEntrants() {
        return this.invitedEntrants;
    }

    /**
     * @return waiting entrants list
     */
    public ArrayList<String> getWaitingEntrants() {
        return this.waitingEntrants;
    }

    /**
     * @return enrolled entrants list
     */
    public ArrayList<String> getEnrolledEntrants() {
        return this.enrolledEntrants;
    }

    /**
     * @return cancelled entrants list
     */
    public ArrayList<String> getCancelledEntrants() {
        return this.cancelledEntrants;
    }

    // -------------------- SETTERS --------------------

    /** @param organizer organizer user ID */
    public void setOrganizer(String organizer) {
        this.organizerID = organizer;
    }

    /** @param eventID event UUID field value */
    public void setEventID(String eventID) {
        this.eventID = eventID;
    }

    /** @param registrationStartDate start date */
    public void setRegistrationStartDate(Date registrationStartDate) {
        this.registrationStartDate = registrationStartDate;
    }

    /** @param registrationEndDate end date */
    public void setRegistrationEndDate(Date registrationEndDate) {
        this.registrationEndDate = registrationEndDate;
    }

    /** @param eventTitle title */
    public void setEventTitle(String eventTitle) {
        this.eventTitle = eventTitle;
    }

    /** @param eventDescription description */
    public void setEventDescription(String eventDescription) {
        this.eventDescription = eventDescription;
    }

    /** @param geoLocationRequired whether geolocation is required */
    public void setGeoLocationRequired(boolean geoLocationRequired) {
        this.geoLocationRequired = geoLocationRequired;
    }

    /** @param lotterySampleSize lottery sample size */
    public void setLotterySampleSize(int lotterySampleSize) {
        this.lotterySampleSize = lotterySampleSize;
    }

    /** @param optionalWaitingListSize waiting list size (-1 if unset) */
    public void setOptionalWaitingListSize(int optionalWaitingListSize) {
        this.optionalWaitingListSize = optionalWaitingListSize;
    }

    /** @param geoLocationMap geolocation map metadata */
    public void setGeoLocationMap(GeoLocationMap geoLocationMap) {
        this.geoLocationMap = geoLocationMap;
    }

    /** @param qrCode qr code object */
    public void setQRCode(QRCode qrCode) {
        this.qrCode = qrCode;
    }

    /** @param poster poster object */
    public void setPoster(Poster poster) {
        this.poster = poster;
    }

    /** @param tags tag list */
    public void setTags(ArrayList<String> tags) {
        this.tags = tags;
    }

    /** @param invitedEntrants invited entrants list */
    public void setInvitedEntrantsList(ArrayList<String> invitedEntrants) {
        this.invitedEntrants = invitedEntrants;
    }

    /** @param waitingEntrants waiting entrants list */
    public void setWaitingEntrants(ArrayList<String> waitingEntrants) {
        this.waitingEntrants = waitingEntrants;
    }

    /** @param enrolledEntrants enrolled entrants list */
    public void setEnrolledEntrantsList(ArrayList<String> enrolledEntrants) {
        this.enrolledEntrants = enrolledEntrants;
    }

    /** @param cancelledEntrants cancelled entrants list */
    public void setCancelledEntrantsList(ArrayList<String> cancelledEntrants) {
        this.cancelledEntrants = cancelledEntrants;;
    }
}
